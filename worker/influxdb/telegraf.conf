[agent]
    flush_interval="500ms"
    

[[inputs.kafka_consumer]]

    brokers = ${BOOTSTRAP_SERVER}

    topics = ["servers.metrics"]
    offset = "oldest"

    max_message_len = 1000000

    data_format = "avro"

    avro_schema_registry = "${SCHEMA_REGISTRY_URL}"

    avro_measurement = "servers_metrics"

    avro_tags = ["server_id"]
    
   
    consumer_group = "telegraf_metrics_consumers"
    compression_codec = 3
    version = "4.0.0"

[[inputs.kafka_consumer]]

    brokers = ${BOOTSTRAP_SERVER}

    topics = ["servers.logs.application"]
    offset = "oldest"

    max_message_len = 1000000

    data_format = "avro"

    avro_schema_registry = "${SCHEMA_REGISTRY_URL}"

    avro_measurement = "servers_logs_application"

    avro_tags = ["server_id"]

    consumer_group = "telegraf_metrics_consumers"
    compression_codec = 3
    
    version = "4.0.0"   

[[inputs.kafka_consumer]]

    brokers = ${BOOTSTRAP_SERVER}

    topics = ["servers.logs.access"]
    offset = "oldest"

    max_message_len = 1000000

    data_format = "avro"

    avro_schema_registry = "${SCHEMA_REGISTRY_URL}"

    avro_measurement = "servers_logs_access"

    avro_tags = ["server_id"]

    consumer_group = "telegraf_metrics_consumers"
    compression_codec = 3

    version = "4.0.0"

[[processors.starlark]]
   namepass = ["servers_metrics", "servers.logs.access", "servers.logs.application"]
  source = '''
def apply(metric):
    if "generation_time" in metric.fields:
        metric.time = metric.fields["generation_time"]
        metric.fields.pop("generation_time")
    return metric
'''

[[outputs.influxdb_v2]]
    urls = ["${INFLUX_URL}"]
    bucket = "kafka"
    organization = ""
    token = "None"
    precision = "ms"
